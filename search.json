[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Big Data for Finance",
    "section": "",
    "text": "Arthur Costa Schaitza - https://faexai.github.io/portfolio2/\nPamela Roland -\nMatheus Kochaki de Liz -"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#como-investir",
    "href": "index.html#como-investir",
    "title": "Big Data for Finance",
    "section": "ðŸ“Œ Como Investir?",
    "text": "ðŸ“Œ Como Investir?\nEssas empresas sÃ£o negociadas na NYSE e podem ser adquiridas atravÃ©s de corretoras internacionais.\n\n\n# Carregar pacotes necessÃ¡rios\nlibrary(quantmod)\n\nCarregando pacotes exigidos: xts\n\n\nCarregando pacotes exigidos: zoo\n\n\n\nAnexando pacote: 'zoo'\n\n\nOs seguintes objetos sÃ£o mascarados por 'package:base':\n\n    as.Date, as.Date.numeric\n\n\nCarregando pacotes exigidos: TTR\n\n\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n\ntickers &lt;- c(\"SAP\", \"ORCL\", \"CRM\", \"NOW\", \"IBM\")  # SAP, Oracle, Salesforce, ServiceNow, IBM\n\n# Baixar dados histÃ³ricos do Yahoo Finance atÃ© 31/12/2024\ngetSymbols(tickers, src = \"yahoo\", from = \"2023-01-01\", to = \"2024-12-31\")\n\n[1] \"SAP\"  \"ORCL\" \"CRM\"  \"NOW\"  \"IBM\" \n\n# Exibir as primeiras linhas dos dados de uma das empresas (ex: IBM)\nhead(NOW)\n\n           NOW.Open NOW.High NOW.Low NOW.Close NOW.Volume NOW.Adjusted\n2023-01-03   395.08   398.65  380.65    385.50    1088000       385.50\n2023-01-04   390.95   397.06  384.74    393.85    1404900       393.85\n2023-01-05   388.45   389.70  365.25    366.32    1790000       366.32\n2023-01-06   371.59   371.59  353.62    366.53    2676700       366.53\n2023-01-09   373.88   392.99  373.19    378.56    2087800       378.56\n2023-01-10   374.37   383.77  374.37    380.84    1064600       380.84\n\n\n\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# Criar um dataframe para armazenar os preÃ§os de fechamento\nstock_data &lt;- data.frame(\n  Date = index(SAP),\n  SAP = Cl(SAP),\n  ORCL = Cl(ORCL),\n  CRM = Cl(CRM),\n  NOW = Cl(NOW),\n  IBM = Cl(IBM)\n)\n\n# Transformar os dados para o formato longo (tidy) para usar no ggplot2\nstock_data_long &lt;- stock_data %&gt;%\n  pivot_longer(cols = -Date, names_to = \"Company\", values_to = \"Close_Price\")\n\n# Criar o grÃ¡fico de sÃ©ries temporais\nggplot(stock_data_long, aes(x = Date, y = Close_Price, color = Company)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"SÃ©rie Temporal dos PreÃ§os de Fechamento das Empresas\",\n       x = \"Data\",\n       y = \"PreÃ§o de Fechamento (USD)\",\n       color = \"Empresa\") +\n  theme_minimal()"
  },
  {
    "objectID": "index.html#por",
    "href": "index.html#por",
    "title": "Big Data for Finance",
    "section": "",
    "text": "Arthur Costa Schaitza - https://faexai.github.io/portfolio2/\nPamela Roland -\nMatheus Kochaki de Liz -"
  },
  {
    "objectID": "index.html#nova-soluÃ§Ã£o",
    "href": "index.html#nova-soluÃ§Ã£o",
    "title": "Big Data for Finance",
    "section": "Nova SoluÃ§Ã£o",
    "text": "Nova SoluÃ§Ã£o\n\n# Carregar pacotes necessÃ¡rios\nlibrary(quantmod)\nlibrary(tidyverse)\n\nâ”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\nâœ” dplyr     1.1.4     âœ” readr     2.1.5\nâœ” forcats   1.0.0     âœ” stringr   1.5.1\nâœ” lubridate 1.9.4     âœ” tibble    3.2.1\nâœ” purrr     1.0.4     \nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::first()  masks xts::first()\nâœ– dplyr::lag()    masks stats::lag()\nâœ– dplyr::last()   masks xts::last()\nâ„¹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(rugarch)\n\nCarregando pacotes exigidos: parallel\n\nAnexando pacote: 'rugarch'\n\nO seguinte objeto Ã© mascarado por 'package:purrr':\n\n    reduce\n\nO seguinte objeto Ã© mascarado por 'package:stats':\n\n    sigma\n\n# 1) Baixar dados histÃ³ricos do Yahoo Finance atÃ© 31/12/2024\ntickers &lt;- c(\"SAP\", \"ORCL\", \"CRM\", \"NOW\", \"IBM\") # SAP, Oracle, Salesforce, ServiceNow, IBM\n\n# Baixar dados histÃ³ricos do Yahoo Finance atÃ© 31/12/2024\ngetSymbols(tickers, src = \"yahoo\", from = \"2023-01-01\", to = \"2024-12-31\")\n\n[1] \"SAP\"  \"ORCL\" \"CRM\"  \"NOW\"  \"IBM\" \n\n# Extrair os preÃ§os de fechamento das aÃ§Ãµes\nSAP &lt;- SAP$SAP.Close\nORCL &lt;- ORCL$ORCL.Close\nCRM &lt;- CRM$CRM.Close\nNOW &lt;- NOW$NOW.Close\nIBM &lt;- IBM$IBM.Close\n\n# Combinar os dados em um Ãºnico dataframe\nstock_data &lt;- merge(SAP, ORCL, CRM, NOW, IBM)\ncolnames(stock_data) &lt;- c(\"SAP\", \"ORCL\", \"CRM\", \"NOW\", \"IBM\")\n\n# Remover valores ausentes (NA)\nstock_data &lt;- na.omit(stock_data)\n\n# 2) Calcular os log-retornos\nlog_returns &lt;- diff(log(stock_data))[-1]\n\n# 3) Analisar a distribuiÃ§Ã£o dos retornos transformados\n# Calcular a frequÃªncia dos retornos positivos e negativos\npositive_returns &lt;- sapply(log_returns, function(x) sum(x &gt; 0))\nnegative_returns &lt;- sapply(log_returns, function(x) sum(x &lt; 0))\n\n# Imprimir os resultados\ncat(\"NÃºmero de retornos positivos:\\n\")\n\nNÃºmero de retornos positivos:\n\nprint(positive_returns)\n\n SAP ORCL  CRM  NOW  IBM \n 273  277  269  297  280 \n\ncat(\"\\nNÃºmero de retornos negativos:\\n\")\n\n\nNÃºmero de retornos negativos:\n\nprint(negative_returns)\n\n SAP ORCL  CRM  NOW  IBM \n 226  221  231  203  219 \n\n# 4) Calcular a volatilidade dos retornos logarÃ­tmicos\n# a) Usando o desvio padrÃ£o\nvolatility_sd &lt;- sapply(log_returns, sd)\ncat(\"\\nVolatilidade (desvio padrÃ£o):\\n\")\n\n\nVolatilidade (desvio padrÃ£o):\n\nprint(volatility_sd)\n\n       SAP       ORCL        CRM        NOW        IBM \n0.01474467 0.01970165 0.02103840 0.02067332 0.01271442 \n\n# b) Usando modelos de volatilidade condicional (GARCH)\n# FunÃ§Ã£o para ajustar o modelo GARCH(1,1) e extrair a volatilidade condicional\nfit_garch &lt;- function(returns) {\n  spec &lt;- ugarchspec(variance.model = list(model = \"sGARCH\", garchOrder = c(1, 1)),\n                     mean.model = list(armaOrder = c(0, 0)))\n  fit &lt;- ugarchfit(spec = spec, data = returns)\n  return(sigma(fit))  # Retorna a volatilidade condicional\n}\n\n# Aplicar o modelo GARCH a cada sÃ©rie de retornos\nconditional_volatility &lt;- sapply(log_returns, fit_garch)\n\n\n# 4) Visualizar a volatilidade condicional\n# Plotar a volatilidade condicional para a primeira aÃ§Ã£o (SAP)\nplot(conditional_volatility[[1]], type = \"l\", col = \"blue\",\n     main = \"Volatilidade Condicional (GARCH) - SAP\",\n     xlab = \"Tempo\", ylab = \"Volatilidade Condicional\")\n\n\n\n\n\n\n\n\n\nExplicaÃ§Ã£o em Markdown:\nEste cÃ³digo R analisa a sÃ©rie de preÃ§os de cinco grandes empresas de software e sistemas (SAP, ORCL, CRM, NOW e IBM) negociadas na NYSE, calculando log-retornos, analisando a distribuiÃ§Ã£o dos retornos e calculando a volatilidade usando dois mÃ©todos: o desvio padrÃ£o e um modelo GARCH.\n1) CÃ¡lculo dos Log-Retornos:\nO cÃ³digo comeÃ§a baixando os dados histÃ³ricos de preÃ§os para as cinco empresas usando a funÃ§Ã£o getSymbols do pacote quantmod. Em seguida, os dados sÃ£o combinados em um Ãºnico dataframe chamado stock_data. Os log-retornos sÃ£o calculados usando a fÃ³rmula log(p_t) - log(p_t-1), onde p_t Ã© o preÃ§o no tempo t. A coluna LogReturn no dataframe stock_data contÃ©m os log-retornos calculados.\n2) AnÃ¡lise da DistribuiÃ§Ã£o dos Retornos:\nApÃ³s calcular os log-retornos, o cÃ³digo analisa a distribuiÃ§Ã£o dos retornos. Ele calcula o nÃºmero de retornos positivos e negativos. Isso fornece uma ideia da direÃ§Ã£o predominante dos retornos ao longo do perÃ­odo analisado. Em geral, espera-se que haja mais retornos positivos do que negativos em um mercado financeiro.\n3) CÃ¡lculo da Volatilidade:\nA volatilidade Ã© uma medida da dispersÃ£o dos retornos em torno de sua mÃ©dia. O cÃ³digo calcula a volatilidade usando dois mÃ©todos:\n\nDesvio PadrÃ£o: O desvio padrÃ£o dos log-retornos Ã© calculado usando a funÃ§Ã£o sd(). Este Ã© um mÃ©todo simples para estimar a volatilidade.\nModelo GARCH (1,1): O modelo GARCH (1,1) Ã© um modelo estatÃ­stico comumente usado para modelar a volatilidade temporal. Ele assume que a volatilidade atual depende da volatilidade passada e de um erro de termo residual. O cÃ³digo ajusta um modelo GARCH(1,1) aos log-retornos e extrai a mÃ©dia da volatilidade condicional, que Ã© uma estimativa da volatilidade da sÃ©rie de preÃ§os.\n\nConclusÃµes:\nOs resultados do cÃ¡lculo dos log-retornos e da volatilidade podem ser usados para avaliar o risco e o retorno de cada ativo. Por exemplo, a volatilidade pode ser usada para calcular o valor em risco (VaR) de um portfÃ³lio. O modelo GARCH Ã© uma ferramenta poderosa para modelar a volatilidade temporal e pode ser usado para prever a volatilidade futura."
  },
  {
    "objectID": "index.html#nova-soluÃ§Ã£o-1",
    "href": "index.html#nova-soluÃ§Ã£o-1",
    "title": "Big Data for Finance",
    "section": "Nova SoluÃ§Ã£o",
    "text": "Nova SoluÃ§Ã£o\n# Carregar pacotes necessÃ¡rios\nlibrary(quantmod)\nlibrary(GARCH)\n\n# Obter dados de preÃ§os da aÃ§Ã£o Apple (AAPL)\n# Usar quantmod para obter dados histÃ³ricos\nAAPL &lt;- getSymbols(\"AAPL\", from = \"2023-01-01\")\n\n# Converter a sÃ©rie de preÃ§os em um dataframe\nAAPL_df &lt;- data.frame(AAPL)\n\n# Calcular os log-reforÃ§os\nAAPL_df$LogReturn &lt;- diff(AAPL_df$AAPL)\n\n# Analisar a distribuiÃ§Ã£o dos log-reforÃ§os\n# Calcular a frequÃªncia de reforÃ§os positivos e negativos\npositive_returns &lt;- sum(AAPL_df$LogReturn &gt; 0)\nnegative_returns &lt;- sum(AAPL_df$LogReturn &lt; 0)\n\ncat(\"FrequÃªncia de reforÃ§os positivos:\", positive_returns, \"\\n\")\ncat(\"FrequÃªncia de reforÃ§os negativos:\", negative_returns, \"\\n\")\n\n# Calcular a volatilidade usando o desvio padrÃ£o\nvolatility_sd &lt;- sd(AAPL_df$LogReturn)\ncat(\"Volatilidade (Desvio PadrÃ£o):\", volatility_sd, \"\\n\")\n\n# Ajustar um modelo GARCH\n# Obter dados de preÃ§os\nprices &lt;- AAPL$AAPL\n\n# Ajustar o modelo GARCH\ngarch_model &lt;- GARCH(data = prices, model = \"GARCH\")\n\n# Extrair parÃ¢metros do modelo\nalpha &lt;- garch_model$estimates[\"alpha\"]\nbeta &lt;- garch_model$estimates[\"beta\"]\nsigma &lt;- garch_model$estimates[\"sigma\"]\n\n# Calcular a volatilidade usando o modelo GARCH\nvolatility_garch &lt;- sigma\n\n# Imprimir resultados\ncat(\"Volatilidade (Modelo GARCH):\", volatility_garch, \"\\n\")\n\n# Criar um grÃ¡fico da distribuiÃ§Ã£o dos log-reforÃ§os\nhist(AAPL_df$LogReturn, main = \"DistribuiÃ§Ã£o dos Log-reforÃ§os da Apple\", xlab = \"Log-reforÃ§os\", col = \"skyblue\")\n\nExplicaÃ§Ã£o em Markdown\nEste cÃ³digo R analisa a sÃ©rie de preÃ§os da aÃ§Ã£o Apple (AAPL) para entender sua volatilidade e distribuiÃ§Ã£o de retornos. Ele realiza as seguintes etapas:\n\nObtenÃ§Ã£o de Dados:\n\nUtiliza o pacote quantmod para baixar dados histÃ³ricos de preÃ§os da aÃ§Ã£o Apple a partir de 1Âº de janeiro de 2023. getSymbols() Ã© uma funÃ§Ã£o conveniente para obter dados financeiros de vÃ¡rias fontes.\n\nCÃ¡lculo dos Log-reforÃ§os:\n\nCalcula os log-reforÃ§os usando a fÃ³rmula padrÃ£o: p_t = ln(p_t) - ln(p_t-1). Isso transforma os retornos percentuais em uma escala logarÃ­tmica, que Ã© mais adequada para anÃ¡lise de volatilidade. A funÃ§Ã£o diff() Ã© usada para calcular a diferenÃ§a entre os preÃ§os consecutivos.\n\nAnÃ¡lise da DistribuiÃ§Ã£o dos Log-reforÃ§os:\n\nCalcula a frequÃªncia de log-reforÃ§os positivos e negativos. Isso fornece uma ideia da direÃ§Ã£o predominante dos retornos. Um nÃºmero maior de log-reforÃ§os positivos indica que a aÃ§Ã£o tem tido um desempenho melhor, enquanto um nÃºmero maior de log-reforÃ§os negativos sugere o oposto.\n\nCÃ¡lculo da Volatilidade:\n\nUsando o Desvio PadrÃ£o: Calcula a volatilidade usando o desvio padrÃ£o dos log-reforÃ§os. O desvio padrÃ£o Ã© uma medida da dispersÃ£o dos dados em torno da mÃ©dia e Ã© uma estimativa simples da volatilidade.\nUsando o Modelo GARCH:\n\nAjuste do Modelo: Ajusta um modelo GARCH (Generalized Autoregressive Conditional Heteroskedasticity) aos log-reforÃ§os. O modelo GARCH Ã© um modelo estatÃ­stico que captura a heteroscedasticidade (variÃ¢ncia nÃ£o constante) na sÃ©rie temporal. O pacote GARCH Ã© usado para ajustar o modelo.\nExtraÃ§Ã£o de ParÃ¢metros: Extrai os parÃ¢metros alpha e beta do modelo GARCH ajustado.\nCÃ¡lculo da Volatilidade: Calcula a volatilidade usando o parÃ¢metro sigma do modelo GARCH.\n\n\nVisualizaÃ§Ã£o:\n\nCria um histograma da distribuiÃ§Ã£o dos log-reforÃ§os. Isso permite visualizar a forma da distribuiÃ§Ã£o dos retornos e identificar quaisquer caracterÃ­sticas importantes, como a presenÃ§a de caudas pesadas (indicando maior probabilidade de eventos extremos).\n\n\nInterpretaÃ§Ã£o dos Resultados:\n\nDistribuiÃ§Ã£o dos Log-reforÃ§os: A anÃ¡lise da frequÃªncia de reforÃ§os positivos e negativos fornece uma visÃ£o geral do desempenho da aÃ§Ã£o.\nVolatilidade (Desvio PadrÃ£o): O desvio padrÃ£o Ã© uma medida inicial da volatilidade.\nVolatilidade (Modelo GARCH): O modelo GARCH fornece uma estimativa mais precisa da volatilidade, levando em consideraÃ§Ã£o a dependÃªncia da variÃ¢ncia ao longo do tempo. O modelo GARCH Ã© geralmente mais preciso do que o desvio padrÃ£o, especialmente para sÃ©ries temporais com heteroscedasticidade.\n\nObservaÃ§Ãµes:\n\nEste cÃ³digo Ã© um exemplo bÃ¡sico e pode ser expandido para incluir anÃ¡lises mais avanÃ§adas, como testes de estacionariedade, anÃ¡lise de resÃ­duos e previsÃ£o de volatilidade.\nA escolha do modelo GARCH apropriado pode depender das caracterÃ­sticas especÃ­ficas da sÃ©rie temporal.\nA anÃ¡lise da volatilidade Ã© apenas uma parte da anÃ¡lise de investimento. Ã‰ importante considerar outros fatores, como o risco, o retorno e os objetivos do investidor."
  }
]