[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Big Data for Finance",
    "section": "",
    "text": "Arthur Costa Schaitza - https://faexai.github.io/portfolio2/\nPamela Roland -\nMatheus Kochaki de Liz -"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#como-investir",
    "href": "index.html#como-investir",
    "title": "Big Data for Finance",
    "section": "üìå Como Investir?",
    "text": "üìå Como Investir?\nEssas empresas s√£o negociadas na NYSE e podem ser adquiridas atrav√©s de corretoras internacionais.\n\n\n# Carregar pacotes necess√°rios\nlibrary(quantmod)\n\nCarregando pacotes exigidos: xts\n\n\nCarregando pacotes exigidos: zoo\n\n\n\nAnexando pacote: 'zoo'\n\n\nOs seguintes objetos s√£o mascarados por 'package:base':\n\n    as.Date, as.Date.numeric\n\n\nCarregando pacotes exigidos: TTR\n\n\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n\ntickers &lt;- c(\"SAP\", \"ORCL\", \"CRM\", \"NOW\", \"IBM\")  # SAP, Oracle, Salesforce, ServiceNow, IBM\n\n# Baixar dados hist√≥ricos do Yahoo Finance at√© 31/12/2024\ngetSymbols(tickers, src = \"yahoo\", from = \"2023-01-01\", to = \"2024-12-31\")\n\n[1] \"SAP\"  \"ORCL\" \"CRM\"  \"NOW\"  \"IBM\" \n\n# Exibir as primeiras linhas dos dados de uma das empresas (ex: IBM)\nhead(NOW)\n\n           NOW.Open NOW.High NOW.Low NOW.Close NOW.Volume NOW.Adjusted\n2023-01-03   395.08   398.65  380.65    385.50    1088000       385.50\n2023-01-04   390.95   397.06  384.74    393.85    1404900       393.85\n2023-01-05   388.45   389.70  365.25    366.32    1790000       366.32\n2023-01-06   371.59   371.59  353.62    366.53    2676700       366.53\n2023-01-09   373.88   392.99  373.19    378.56    2087800       378.56\n2023-01-10   374.37   383.77  374.37    380.84    1064600       380.84\n\n\n\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# Criar um dataframe para armazenar os pre√ßos de fechamento\nstock_data &lt;- data.frame(\n  Date = index(SAP),\n  SAP = Cl(SAP),\n  ORCL = Cl(ORCL),\n  CRM = Cl(CRM),\n  NOW = Cl(NOW),\n  IBM = Cl(IBM)\n)\n\n# Transformar os dados para o formato longo (tidy) para usar no ggplot2\nstock_data_long &lt;- stock_data %&gt;%\n  pivot_longer(cols = -Date, names_to = \"Company\", values_to = \"Close_Price\")\n\n# Criar o gr√°fico de s√©ries temporais\nggplot(stock_data_long, aes(x = Date, y = Close_Price, color = Company)) +\n  geom_line(linewidth = 1) +\n  labs(title = \"S√©rie Temporal dos Pre√ßos de Fechamento das Empresas\",\n       x = \"Data\",\n       y = \"Pre√ßo de Fechamento (USD)\",\n       color = \"Empresa\") +\n  theme_minimal()"
  },
  {
    "objectID": "index.html#por",
    "href": "index.html#por",
    "title": "Big Data for Finance",
    "section": "",
    "text": "Arthur Costa Schaitza - https://faexai.github.io/portfolio2/\nPamela Roland -\nMatheus Kochaki de Liz -"
  },
  {
    "objectID": "index.html#nova-solu√ß√£o",
    "href": "index.html#nova-solu√ß√£o",
    "title": "Big Data for Finance",
    "section": "Nova Solu√ß√£o",
    "text": "Nova Solu√ß√£o\n\n# Carregar pacotes necess√°rios\nlibrary(quantmod)\nlibrary(tidyverse)\n\n‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ\n‚úî dplyr     1.1.4     ‚úî readr     2.1.5\n‚úî forcats   1.0.0     ‚úî stringr   1.5.1\n‚úî lubridate 1.9.4     ‚úî tibble    3.2.1\n‚úî purrr     1.0.4     \n‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n‚úñ dplyr::filter() masks stats::filter()\n‚úñ dplyr::first()  masks xts::first()\n‚úñ dplyr::lag()    masks stats::lag()\n‚úñ dplyr::last()   masks xts::last()\n‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(rugarch)\n\nCarregando pacotes exigidos: parallel\n\nAnexando pacote: 'rugarch'\n\nO seguinte objeto √© mascarado por 'package:purrr':\n\n    reduce\n\nO seguinte objeto √© mascarado por 'package:stats':\n\n    sigma\n\n# 1) Baixar dados hist√≥ricos do Yahoo Finance at√© 31/12/2024\ntickers &lt;- c(\"SAP\", \"ORCL\", \"CRM\", \"NOW\", \"IBM\") # SAP, Oracle, Salesforce, ServiceNow, IBM\n\n# Baixar dados hist√≥ricos do Yahoo Finance at√© 31/12/2024\ngetSymbols(tickers, src = \"yahoo\", from = \"2023-01-01\", to = \"2024-12-31\")\n\n[1] \"SAP\"  \"ORCL\" \"CRM\"  \"NOW\"  \"IBM\" \n\n# Extrair os pre√ßos de fechamento das a√ß√µes\nSAP &lt;- SAP$SAP.Close\nORCL &lt;- ORCL$ORCL.Close\nCRM &lt;- CRM$CRM.Close\nNOW &lt;- NOW$NOW.Close\nIBM &lt;- IBM$IBM.Close\n\n# Combinar os dados em um √∫nico dataframe\nstock_data &lt;- merge(SAP, ORCL, CRM, NOW, IBM)\ncolnames(stock_data) &lt;- c(\"SAP\", \"ORCL\", \"CRM\", \"NOW\", \"IBM\")\n\n# Remover valores ausentes (NA)\nstock_data &lt;- na.omit(stock_data)\n\n# 2) Calcular os log-retornos\nlog_returns &lt;- diff(log(stock_data))[-1]\n\n# 3) Analisar a distribui√ß√£o dos retornos transformados\n# Calcular a frequ√™ncia dos retornos positivos e negativos\npositive_returns &lt;- sapply(log_returns, function(x) sum(x &gt; 0))\nnegative_returns &lt;- sapply(log_returns, function(x) sum(x &lt; 0))\n\n# Imprimir os resultados\ncat(\"N√∫mero de retornos positivos:\\n\")\n\nN√∫mero de retornos positivos:\n\nprint(positive_returns)\n\n SAP ORCL  CRM  NOW  IBM \n 273  277  269  297  280 \n\ncat(\"\\nN√∫mero de retornos negativos:\\n\")\n\n\nN√∫mero de retornos negativos:\n\nprint(negative_returns)\n\n SAP ORCL  CRM  NOW  IBM \n 226  221  231  203  219 \n\n# 4) Calcular a volatilidade dos retornos logar√≠tmicos\n# a) Usando o desvio padr√£o\nvolatility_sd &lt;- sapply(log_returns, sd)\ncat(\"\\nVolatilidade (desvio padr√£o):\\n\")\n\n\nVolatilidade (desvio padr√£o):\n\nprint(volatility_sd)\n\n       SAP       ORCL        CRM        NOW        IBM \n0.01474467 0.01970165 0.02103840 0.02067332 0.01271442 \n\n# b) Usando modelos de volatilidade condicional (GARCH)\n# Fun√ß√£o para ajustar o modelo GARCH(1,1) e extrair a volatilidade condicional\nfit_garch &lt;- function(returns) {\n  spec &lt;- ugarchspec(variance.model = list(model = \"sGARCH\", garchOrder = c(1, 1)),\n                     mean.model = list(armaOrder = c(0, 0)))\n  fit &lt;- ugarchfit(spec = spec, data = returns)\n  return(sigma(fit))  # Retorna a volatilidade condicional\n}\n\n# Aplicar o modelo GARCH a cada s√©rie de retornos\nconditional_volatility &lt;- sapply(log_returns, fit_garch)\n\n\n# 4) Visualizar a volatilidade condicional\n# Plotar a volatilidade condicional para a primeira a√ß√£o (SAP)\nplot(conditional_volatility[[1]], type = \"l\", col = \"blue\",\n     main = \"Volatilidade Condicional (GARCH) - SAP\",\n     xlab = \"Tempo\", ylab = \"Volatilidade Condicional\")\n\n\n\n\n\n\n\n\n\nExplica√ß√£o em Markdown:\nEste c√≥digo R analisa a s√©rie de pre√ßos de cinco grandes empresas de software e sistemas (SAP, ORCL, CRM, NOW e IBM) negociadas na NYSE, calculando log-retornos, analisando a distribui√ß√£o dos retornos e calculando a volatilidade usando dois m√©todos: o desvio padr√£o e um modelo GARCH.\n1) C√°lculo dos Log-Retornos:\nO c√≥digo come√ßa baixando os dados hist√≥ricos de pre√ßos para as cinco empresas usando a fun√ß√£o getSymbols do pacote quantmod. Em seguida, os dados s√£o combinados em um √∫nico dataframe chamado stock_data. Os log-retornos s√£o calculados usando a f√≥rmula log(p_t) - log(p_t-1), onde p_t √© o pre√ßo no tempo t. A coluna LogReturn no dataframe stock_data cont√©m os log-retornos calculados.\n2) An√°lise da Distribui√ß√£o dos Retornos:\nAp√≥s calcular os log-retornos, o c√≥digo analisa a distribui√ß√£o dos retornos. Ele calcula o n√∫mero de retornos positivos e negativos. Isso fornece uma ideia da dire√ß√£o predominante dos retornos ao longo do per√≠odo analisado. Em geral, espera-se que haja mais retornos positivos do que negativos em um mercado financeiro.\n3) C√°lculo da Volatilidade:\nA volatilidade √© uma medida da dispers√£o dos retornos em torno de sua m√©dia. O c√≥digo calcula a volatilidade usando dois m√©todos:\n\nDesvio Padr√£o: O desvio padr√£o dos log-retornos √© calculado usando a fun√ß√£o sd(). Este √© um m√©todo simples para estimar a volatilidade.\nModelo GARCH (1,1): O modelo GARCH (1,1) √© um modelo estat√≠stico comumente usado para modelar a volatilidade temporal. Ele assume que a volatilidade atual depende da volatilidade passada e de um erro de termo residual. O c√≥digo ajusta um modelo GARCH(1,1) aos log-retornos e extrai a m√©dia da volatilidade condicional, que √© uma estimativa da volatilidade da s√©rie de pre√ßos.\n\nConclus√µes:\nOs resultados do c√°lculo dos log-retornos e da volatilidade podem ser usados para avaliar o risco e o retorno de cada ativo. Por exemplo, a volatilidade pode ser usada para calcular o valor em risco (VaR) de um portf√≥lio. O modelo GARCH √© uma ferramenta poderosa para modelar a volatilidade temporal e pode ser usado para prever a volatilidade futura."
  },
  {
    "objectID": "index.html#nova-solu√ß√£o-1",
    "href": "index.html#nova-solu√ß√£o-1",
    "title": "Big Data for Finance",
    "section": "Nova Solu√ß√£o",
    "text": "Nova Solu√ß√£o\n# Carregar pacotes necess√°rios\nlibrary(quantmod)\nlibrary(GARCH)\n\n# Obter dados de pre√ßos da a√ß√£o Apple (AAPL)\n# Usar quantmod para obter dados hist√≥ricos\nAAPL &lt;- getSymbols(\"AAPL\", from = \"2023-01-01\")\n\n# Converter a s√©rie de pre√ßos em um dataframe\nAAPL_df &lt;- data.frame(AAPL)\n\n# Calcular os log-refor√ßos\nAAPL_df$LogReturn &lt;- diff(AAPL_df$AAPL)\n\n# Analisar a distribui√ß√£o dos log-refor√ßos\n# Calcular a frequ√™ncia de refor√ßos positivos e negativos\npositive_returns &lt;- sum(AAPL_df$LogReturn &gt; 0)\nnegative_returns &lt;- sum(AAPL_df$LogReturn &lt; 0)\n\ncat(\"Frequ√™ncia de refor√ßos positivos:\", positive_returns, \"\\n\")\ncat(\"Frequ√™ncia de refor√ßos negativos:\", negative_returns, \"\\n\")\n\n# Calcular a volatilidade usando o desvio padr√£o\nvolatility_sd &lt;- sd(AAPL_df$LogReturn)\ncat(\"Volatilidade (Desvio Padr√£o):\", volatility_sd, \"\\n\")\n\n# Ajustar um modelo GARCH\n# Obter dados de pre√ßos\nprices &lt;- AAPL$AAPL\n\n# Ajustar o modelo GARCH\ngarch_model &lt;- GARCH(data = prices, model = \"GARCH\")\n\n# Extrair par√¢metros do modelo\nalpha &lt;- garch_model$estimates[\"alpha\"]\nbeta &lt;- garch_model$estimates[\"beta\"]\nsigma &lt;- garch_model$estimates[\"sigma\"]\n\n# Calcular a volatilidade usando o modelo GARCH\nvolatility_garch &lt;- sigma\n\n# Imprimir resultados\ncat(\"Volatilidade (Modelo GARCH):\", volatility_garch, \"\\n\")\n\n# Criar um gr√°fico da distribui√ß√£o dos log-refor√ßos\nhist(AAPL_df$LogReturn, main = \"Distribui√ß√£o dos Log-refor√ßos da Apple\", xlab = \"Log-refor√ßos\", col = \"skyblue\")\n\nExplica√ß√£o em Markdown\nEste c√≥digo R analisa a s√©rie de pre√ßos da a√ß√£o Apple (AAPL) para entender sua volatilidade e distribui√ß√£o de retornos. Ele realiza as seguintes etapas:\n\nObten√ß√£o de Dados:\n\nUtiliza o pacote quantmod para baixar dados hist√≥ricos de pre√ßos da a√ß√£o Apple a partir de 1¬∫ de janeiro de 2023. getSymbols() √© uma fun√ß√£o conveniente para obter dados financeiros de v√°rias fontes.\n\nC√°lculo dos Log-refor√ßos:\n\nCalcula os log-refor√ßos usando a f√≥rmula padr√£o: p_t = ln(p_t) - ln(p_t-1). Isso transforma os retornos percentuais em uma escala logar√≠tmica, que √© mais adequada para an√°lise de volatilidade. A fun√ß√£o diff() √© usada para calcular a diferen√ßa entre os pre√ßos consecutivos.\n\nAn√°lise da Distribui√ß√£o dos Log-refor√ßos:\n\nCalcula a frequ√™ncia de log-refor√ßos positivos e negativos. Isso fornece uma ideia da dire√ß√£o predominante dos retornos. Um n√∫mero maior de log-refor√ßos positivos indica que a a√ß√£o tem tido um desempenho melhor, enquanto um n√∫mero maior de log-refor√ßos negativos sugere o oposto.\n\nC√°lculo da Volatilidade:\n\nUsando o Desvio Padr√£o: Calcula a volatilidade usando o desvio padr√£o dos log-refor√ßos. O desvio padr√£o √© uma medida da dispers√£o dos dados em torno da m√©dia e √© uma estimativa simples da volatilidade.\nUsando o Modelo GARCH:\n\nAjuste do Modelo: Ajusta um modelo GARCH (Generalized Autoregressive Conditional Heteroskedasticity) aos log-refor√ßos. O modelo GARCH √© um modelo estat√≠stico que captura a heteroscedasticidade (vari√¢ncia n√£o constante) na s√©rie temporal. O pacote GARCH √© usado para ajustar o modelo.\nExtra√ß√£o de Par√¢metros: Extrai os par√¢metros alpha e beta do modelo GARCH ajustado.\nC√°lculo da Volatilidade: Calcula a volatilidade usando o par√¢metro sigma do modelo GARCH.\n\n\nVisualiza√ß√£o:\n\nCria um histograma da distribui√ß√£o dos log-refor√ßos. Isso permite visualizar a forma da distribui√ß√£o dos retornos e identificar quaisquer caracter√≠sticas importantes, como a presen√ßa de caudas pesadas (indicando maior probabilidade de eventos extremos).\n\n\nInterpreta√ß√£o dos Resultados:\n\nDistribui√ß√£o dos Log-refor√ßos: A an√°lise da frequ√™ncia de refor√ßos positivos e negativos fornece uma vis√£o geral do desempenho da a√ß√£o.\nVolatilidade (Desvio Padr√£o): O desvio padr√£o √© uma medida inicial da volatilidade.\nVolatilidade (Modelo GARCH): O modelo GARCH fornece uma estimativa mais precisa da volatilidade, levando em considera√ß√£o a depend√™ncia da vari√¢ncia ao longo do tempo. O modelo GARCH √© geralmente mais preciso do que o desvio padr√£o, especialmente para s√©ries temporais com heteroscedasticidade.\n\nObserva√ß√µes:\n\nEste c√≥digo √© um exemplo b√°sico e pode ser expandido para incluir an√°lises mais avan√ßadas, como testes de estacionariedade, an√°lise de res√≠duos e previs√£o de volatilidade.\nA escolha do modelo GARCH apropriado pode depender das caracter√≠sticas espec√≠ficas da s√©rie temporal.\nA an√°lise da volatilidade √© apenas uma parte da an√°lise de investimento. √â importante considerar outros fatores, como o risco, o retorno e os objetivos do investidor."
  }
]