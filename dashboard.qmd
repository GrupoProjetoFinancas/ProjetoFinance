---
title: "dashboard"
format: dashboard
---

## ROW {.tabset}

### Plots

```{r}
#| echo: false

library(tidyquant)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lubridate)

# Definir os tickers
tickers <- c("SAP", "ORCL", "CRM", "NOW", "IBM")

# Baixar os dados hist√≥ricos
data <- tq_get(tickers, from = Sys.Date() - years(5), to = Sys.Date())

# Garantir que a coluna "date" esteja no formato correto
data <- data %>% 
  mutate(date = ymd(date))  # Use dmy() for "day-month-year" formats

# Selecionar apenas as colunas de interesse
portfolio_prices <- data %>% select(date, symbol, adjusted) %>% 
  spread(key = symbol, value = adjusted)

# Remover valores ausentes
portfolio_prices <- na.omit(portfolio_prices)

# Calcular log-retornos
log_returns <- portfolio_prices %>% mutate(across(-date, ~ log(.) - log(lag(.))))

# Remover a primeira linha com valores NA
log_returns <- log_returns %>% drop_na()

# Transformar para formato longo
log_returns_long <- log_returns %>% pivot_longer(-date, names_to = "Ativo", values_to = "Log_Retorno")

# Criar lista de gr√°ficos
plots <- list()

for (ticker in tickers) {
  p <- ggplot(filter(log_returns_long, Ativo == ticker), aes(x = date, y = Log_Retorno)) +
    geom_line(color = "blue") +
    ggtitle(paste("Log-Retorno de", ticker)) +
    theme_minimal()
  
  plots[[ticker]] <- p  # Armazena o gr√°fico na lista
}
# Criar gr√°ficos individuais para cada ativo
plots <- list()
for (ticker in tickers) {
  p <- ggplot(filter(log_returns_long, Ativo == ticker), aes(x = date, y = Log_Retorno)) +
    geom_line(color = "blue") +
    ggtitle(paste("Log-Retorno de", ticker)) +
    theme_minimal()
  plots[[ticker]] <- p
}

# Exibir os gr√°ficos em cards organizados em uma grade
layout <- "
  ABC
  DEF
"


```

### **üìä 2. Visualizando as previs√µes de volatilidade**

```{r}
#| echo: false
library(rugarch)
library(forecast)
library(ggplot2)
library(dplyr)

# Criar lista para armazenar previs√µes
previsoes <- list()

for (ticker in tickers) {
  
  print(paste("Processando:", ticker))  # Mensagem no console
  
  # Selecionar os retornos do ativo
  returns <- log_returns %>% select(date, all_of(ticker)) %>% drop_na()
  
  # Converter para s√©rie temporal
  ts_data <- ts(returns[[ticker]], frequency = 252)  # Assumindo 252 dias √∫teis no ano
  
  # Ajustar ARIMA automaticamente
  arima_model <- auto.arima(ts_data, seasonal = FALSE)
  
  # Especifica√ß√£o do modelo GARCH(1,1)
  spec <- ugarchspec(
    variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
    mean.model = list(armaOrder = c(0,0)), 
    distribution.model = "norm"
  )

  # Ajustar o modelo GARCH nos res√≠duos do ARIMA
  garch_fit <- ugarchfit(spec, ts_data)

  # Fazer previs√µes para os pr√≥ximos 100 dias
  garch_forecast <- ugarchforecast(garch_fit, n.ahead = 100)
  
  # Extraindo a previs√£o da volatilidade
  volatility_forecast <- as.numeric(sigma(garch_forecast))

  # Criar dataframe de previs√£o
  forecast_dates <- seq(max(returns$date), by="days", length.out=100)
  
  # Assegurar que os dados est√£o corretamente alinhados
  if (length(volatility_forecast) == length(forecast_dates)) {
    forecast_df <- data.frame(Date = forecast_dates, Volatility = volatility_forecast, Ticker = ticker)
    previsoes[[ticker]] <- forecast_df  # Armazenar previs√£o corretamente
  } else {
    warning(paste("Erro de dimens√£o para", ticker))
  }
}

# Juntar todas as previs√µes em um √∫nico dataframe
forecast_data <- bind_rows(previsoes) %>% drop_na()


ggplot(forecast_data, aes(x = Date, y = Volatility, color = Ticker)) +
  geom_line(linewidth=1) +
  ggtitle("Previs√£o da Volatilidade - GARCH(1,1) para 5 A√ß√µes") +
  xlab("Data") + ylab("Volatilidade Esperada") +
  theme_minimal()



```
